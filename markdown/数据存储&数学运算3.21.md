# **数据存储&数学运算**

## **符号、指数和尾数**

在一个二进制数规范化之后，我们只存储了一个数的三部分信息符号、指数和尾数(小数点右边的位)。例如，+1000111.0101规范化后变成为

|      |               |                |
| ---- | ------------- | -------------- |
| 符号 | 指数          | 尾数           |
| +    | 2<sup>6</sup> | × 1.0001110101 |
| +    | 6             | 0001110101     |

**注意：小数点和定点部分左边的位1、并没有存储，它们是隐含的。**

## **浮点数表示法的IEEE标准**

单精度数格式采用总共**32位**来存储一个浮点表示法的实数。符号占用1位(0为正，1为负)，指数占用8位(使用偏移量127)，尾数使用23位(无符号数)。该标准有时称为**余127码**(Excess_127)，因为偏移量是127。

双精度数格式采用总共**64位**来存储一个浮点表示法的实数。符号占用1位(0为正，1为负)，指数占用11位(使用偏移量1023)，尾数使用52位。该标准有时称为**余1023码**(Excess_1023)，因为偏移量是1023。表3-2总结了这两种标准的规格。

**例3.23** 写出十进制数5.75的余127码(单精度)表示法。

**解**

1. 符号为正，所以S=0。
2. 十进制转换为二进制5.75=(101.11)<sub>2</sub>。
3. 规范化(101.11)<sub>2</sub>=(1.0111)<sub>2</sub> × 2<sup>2</sup>
4. E=2+127=129=(10000001)<sub>2</sub>，M=(0111)<sub>2</sub>。我们需要在M的右边增加19个0使之成为23位。
5. 该表示法如下所示：

|      |          |                         |
| ---- | -------- | ----------------------- |
| S    | E        | M                       |
| 0    | 10000001 | 01110000000000000000000 |

## **利用位模式表示符号**

位模式的长度取决于符号的数量，但是它们的关系并不是线性的，而是**对数的**。如果需要2个符号，位模式长度将是1位(log<sub>2</sub><sup>2</sup>=1)，如果需要4个符号，长度将是2位(log<sub>2</sub><sup>4</sup>=2)。从表3-3中可以很容易看出它们之间的关系。2位的位模式能表示4种不同的形式00,01,10和11。这些形式中的任何一种都可用来代表一个字符。同样，3位的位模式有8种不同的形式000,001,010,011,100，101，110和111。

**符号数量和位模式长度的关系**

|            |              |      |               |              |
| ---------- | ------------ | ---- | ------------- | ------------ |
| 符号的数量 | 位撲式的长度 | ※    | 符号的数量    | 位模式的长度 |
| 2          | 1            | ※    | 128           | 7            |
| 4          | 2            | ※    | 256           | 8            |
| 8          | 3            | ※    | 65 536        | 16           |
| 16         | 4            | ※    | 4 294 967 296 | 32           |

## **ASCII**

**美国国家标准协会**(ANSI)开发了一个被称为**美国信息交换标准码**(ASCII)的代码。该代码使用7位表示每个符号。即该代码可以定义27=128种不同的符号。

## **真彩色**

用于像素编码的技术之一称为真彩色，它使用24位来编码一个像素。在该技术中，每个三原色(RGB)都表示为8位。因为该技术中8位模式可以表示0～255之间的一个数，所以每种色彩都由0～255之间的三维数字表示。表3-4显示了该技术中用于一些颜色的3个值。

**表3-4定义为真彩色的一些颜色**

| 颜色 | 红   | 绿   | 蓝   | 颜色   | 红   | 绿   | 蓝   |
| ---- | ---- | ---- | ---- | ------ | ---- | ---- | ---- |
| 黑色 | 0    | 0    | 0    | 黄色   | 255  | 255  | 0    |
| 红色 | 255  | 0    | 0    | 青色   | 0    | 255  | 255  |
| 绿色 | 0    | 255  | 0    | 紫红色 | 255  | 0    | 255  |
| 蓝色 | 0    | 0    | 255  | 白色   | 255  | 255  | 255  |

注意真彩色模式可以编码224或16 777 216种颜色。换言之，各个像素的色彩深度是这些值的其中之一。

# **数学运算**

## ***与 (AND)***

AND运算符是二元运算符它有两个输入。如果输入都是1，则输出为1，而在其他三种情况下，输出都是0。AND运算符的真值表有4行，因为两个输入有4种可能的输入组合。

**特性：AND运算符有趣的一点是如果一个输入中有一位是0，则不需要检查其他输入中的相应的位，便可迅速得到结果为0。**当我们讨论此运算符在位模式层次上的应用时，我们将用到这个特性。

## **异或(XOR)**

当输入相同时，则输出为0 。当输入不同时，则输出为1 。

**特性：XOR的特性是如果输入中的一位是1，那结果就是与其他输入中相应位相反。**

0⊕0=0，**1⊕0=1**，0⊕1=1，**1⊕1=0**

## **逻辑移位**

逻辑右移运算把每一位向右移动一个位置。在n位模式中，最右位丢失，最左位填0。逻辑左移运算把每一位向左移动一个位置。在n位模式中，最左位丢失，最右位填0。图4-3显示了对一个8位模式的逻辑右移和逻辑左移。

## **算数右移**

算术右移**符号位要一起移动，并且在左边补上符号位，**也就是如果符号位是1就补1符号位是0就补0

比如：11100算术右移一位为11110（符号位1跟着一起移动并且左边补了1）

对于二进制的数值来说右移n位等于原来的数值除以2的n次方

比如10110100十进制是-76（**需要先将这个补码转换成原码之后再转换成十进制**），右移两位后是11101101转成十进制是-19恰好是76的4倍。

ps：这种倍数关系只适用于右移后被舍弃的低位不含1的情况，否则每舍一次1则代表余数被舍去，保留整数部分。

**注意：计算机储存负数是用补码来储存的，11101101计算机发现首位是1，就用补码转换成源码后再加上负号就是-19**

## **算数左移**

**算术左移丢弃符号位，接受它的左边的位作为符号位。如果新的符号位与原先的相同，那么运算成功，否则发生上溢或下溢，结果是非法的。**

算术左移和逻辑左移一样都是右边补0：

比如 00101011

算术左移一位:01010110

逻辑左移一位:01010110

对于二进制的数值来说左移n位等于原来的数值乘以2的n次方

比如00011010十进制是26，左移两位后是01101000转成十进制是104恰好是26的4倍。

| 算术左移 | 01111111（是正数，即为原码，127）                            | 原始的 |
| -------- | ------------------------------------------------------------ | ------ |
|          | 1111111**0**（**符号位为1，用补码转换成00000010, 再加上负号，是-2**） | 移位的 |

原始数是127，新的数是-2。因为上溢发生，所以结果非法。期望的答案是127 × 2=254，这个数不能用8位模式表示。

